{"version":3,"sources":["src/ProgressStream.js"],"names":[],"mappings":"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","file":"lib","sourcesContent":["/**\n * A transform that you can insert anywhere in your chain to monitor what is\n * happening in a stream.\n * @module ProgressStream\n */\n\n\"use strict\";\n\nimport { Transform } from \"stream\";\nimport { mix, Mixin } from \"mixwith\";\n\n/**\n * A stream that reports progress and state via various mechanisms\n * @param {object} options The options for the stream. These are passed directly to the stream and any leftovers are used by this class.\n * @param {number} options.reportAt How many records pass before progress is reported\n * @param {number} options.total The total number of rows to be processed. If 0, then percentages will not be calculated\n * @name module:ProgressStream\n */\nconst Progressor = ( superclass ) => class extends superclass {\n\n\tconstructor( options ) {\n\t\toptions = options || {};\n\t\tsuper( options );\n\n\t\t/**\n\t\t * How many records pass before progress is reported. Defaults to 50,000\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._reportAt = options.reportAt || 50000;\n\n\t\t/**\n\t\t * The total number of rows to be processed. If 0, then percentages will not be calculated\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._total = options.total || 0;\n\n\t\t/**\n\t\t * Meter event. Raise this for every chunk/object/part you process.\n\t\t * @event module:ProgressStream#sample\n\t\t */\n\t\tthis.on( \"sample\", this._sample );\n\n\t\t/**\n\t\t * Raise this event to tell the stream to start monitoring\n\t\t *  @event module:ProgressStream#start\n\t\t */\n\t\tthis.on( \"start\", this._startMetering );\n\n\t\t/**\n\t\t * Raise this event to tell the stream to stop monitoring\n\t\t *  @event module:ProgressStream#end\n\t\t */\n\t\tthis.on( \"end\", this._endMetering );\n\n\t\t/**\n\t\t * The metrics we track\n\t\t *\n\t\t * @type {object}\n\t\t * @private\n\t\t */\n\t\tthis._metrics = {\n\t\t\t/**\n\t\t\t * The number of chunks found as now\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tnumSamples: 0,\n\t\t\t/**\n\t\t\t * The Number of records expected, this may be 0 as it is optional\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\texpected  : options.total || 0,\n\t\t\t/**\n\t\t\t * The rate since the progressor was started\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\trate      : 0,\n\t\t\t/**\n\t\t\t * The rate of the last sample\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tlastRate  : 0\n\t\t};\n\n\t\t/**\n\t\t * Tracks timing per sample\n\t\t * @type {object}\n\t\t * @private\n\t\t */\n\t\tthis._timer = {\n\t\t\t/**\n\t\t\t * Start time in milliseconds epoch\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tstart     : 0,\n\t\t\t/**\n\t\t\t * End time in milliseconds epoch\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tend       : 0,\n\t\t\t/**\n\t\t\t * Total time in milliseconds as of last sample\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tlength    : 0,\n\t\t\t/**\n\t\t\t * Last sample time in milliseconds epoch\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tlast      : 0,\n\t\t\t/**\n\t\t\t * Total time in milliseconds for the last sample\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tlastLength: 0\n\t\t};\n\n\t\t/**\n\t\t * Have we started recording stuff?\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._started = false;\n\t}\n\n\t/**\n\t * Returns the current metric object. This may change each time you call it.\n\t * @returns {object}\n\t */\n\tget _clockValue() {\n\t\treturn JSON.parse( JSON.stringify( this._timer ) );\n\t}\n\n\t/**\n\t * Time has passed\n\t * @private\n\t */\n\t_recordTick() {\n\t\tif ( this._timer.start === 0 ) {\n\t\t\tthis._timer.start = Date.now();\n\t\t}\n\n\t\tconst n                = Date.now();\n\t\tthis._timer.lastLength = n - this._timer.last;\n\t\tthis._timer.last       = n;\n\t\tthis._timer.length     = n - this._timer.start;\n\t}\n\n\t/**\n\t * Stop the clock\n\t * @private\n\t */\n\t_endClock() {\n\t\tthis._timer.end = Date.now();\n\t\tthis._recordTick();\n\t}\n\n\t/**\n\t * Starts the clock\n\t * @private\n\t */\n\t_startClock() {\n\t\tthis._timer.start = Date.now();\n\t\tthis._recordTick();\n\t}\n\n\t/**\n\t * Start gathering metrics\n\t * @private\n\t */\n\t_startMetering() {\n\t\tif ( !this._started ) {\n\t\t\tthis._started = true;\n\t\t\tthis._startClock();\n\t\t\tthis.emit( \"starting\" );\n\t\t}\n\t}\n\n\t/**\n\t * Stop gather metrics\n\t * @private\n\t */\n\t_endMetering() {\n\t\tthis._endClock();\n\n\t}\n\n\t_wrapMetrics() {\n\t\tthis._recordTick();\n\t\tconst retVal     = JSON.parse( JSON.stringify( this._metrics ) );\n\t\tretVal.clock     = this._clockValue;\n\t\tretVal.rate      = this._metrics.numSamples / retVal.clock.length;\n\t\tretVal.lastRate  = this._metrics.numSamples / retVal.clock.lastLength;\n\t\tretVal.completed = this._timer.end > 0;\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * The current stream progress pointer\n\t * @type {number}\n\t */\n\tget counter() {\n\t\treturn this._metrics.recordCounter;\n\t}\n\n\t/**\n\t * Add a sample\n\t * @private\n\t */\n\t_sample() {\n\t\tthis._startMetering();\n\n\t\tthis._metrics.numSamples++;\n\n\t\tif ( this._metrics.numSamples % this._reportAt === 0 ) {\n\t\t\t_recordTick();\n\t\t\tthis.emit( \"progress\", this._wrapMetrics() );\n\t\t}\n\n\t}\n\n}\n\nexport class ProgressStream extends mix( Transform ).with( Progressor ) {\n\tconstructor( options ) {\n\t\tsuper( options );\n\t}\n\n\t_transform( chunk, enc, callback ) {\n\t\tthis._sample();\n\t\tthis.push( chunk, enc );\n\t\treturn callback();\n\t}\n}\n"]}